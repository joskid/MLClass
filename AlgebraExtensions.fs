namespace MathNet.Numerics.LinearAlgebra.Double

open MathNet.Numerics.LinearAlgebra.Double
open MathNet.Numerics.LinearAlgebra.Generic

module Vector = 
    let inline length (v:Vector<float>) = v.Count

    /// Fold all entries of a vector in reverse order.
    let inline foldBack (f: float -> 'a -> 'a) (acc0: 'a) (v: #Vector<float>) =
        let mutable acc = acc0
        for i=2 to v.Count do
            acc <- f (v.Item(v.Count - i)) acc
        acc

module Matrix =
    let inline rowCount (m:Matrix<float>) = m.RowCount
    let inline columnCount (m:Matrix<float>) = m.ColumnCount

    /// Map every matrix column into an element in a sequence using the given position dependent function.
    let inline mapCols (f: int -> Vector<float> -> 'a) (A: #Matrix<float>) =
        A.ColumnEnumerator() |> Seq.map (fun (j, col) -> f j col)

    /// Map every matrix row into an element in a sequence using the given position dependent function.
    let inline mapRows (f: int -> Vector<float> -> 'a) (A: #Matrix<float>) =
        A.RowEnumerator() |> Seq.map (fun (i, row) -> f i row)

    /// Returns the sum of the results generated by applying the function to each column of the matrix.
    let inline sumColsBy (f: int -> Vector<float> -> 'a) (A: #Matrix<float>) =
        mapCols f A |> Seq.reduce (+)
    
    /// Returns the sum of the results generated by applying the function to each row of the matrix.
    let inline sumRowsBy (f: int -> Vector<float> -> 'a) (A: #Matrix<float>) =
        mapRows f A |> Seq.reduce (+)

    /// Fold a function over all matrix elements in reverse order.
    let inline foldBack (f: float -> 'a -> 'a) (acc0: 'a) (A: #Matrix<float>) =
        let n = A.RowCount
        let m = A.ColumnCount
        let mutable acc = acc0
        for i in n-1 .. -1 .. 0 do
            for j in n-1 .. -1 .. 0 do
                acc <- f (A.Item(i,j)) acc
        acc
